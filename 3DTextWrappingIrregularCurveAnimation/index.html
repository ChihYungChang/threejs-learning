<script
  async
  src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
></script>
<link rel="stylesheet" href="../style.css" />

<script type="importmap">
  {
    "imports": {
      "three": "../lib/build/three.module.js",
      "three/addons/": "../lib/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from "three";
  import { TransformControls } from "three/addons/controls/TransformControls.js";
  import Stats from "three/addons/libs/stats.module.js";
  import { InstancedFlow } from "three/addons/modifiers/CurveModifier.js";
  import { FontLoader } from "three/addons/loaders/FontLoader.js";
  import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

  const TEXT = [
    "大数据",
    "云计算",
    "虚拟现实",
    "XR拓展",
    "增强现实",
    "5G互联网",
    "数字人",
    "虚实交互",
    "物联网",
    "元宇宙",
    "可视化",
    "AIGC",
    "人工智能",
  ];

  const ACTION_SELECT = 1,
    ACTION_NONE = 0;
  const curveHandles = [];
  const mouse = new THREE.Vector2();

  let stats;
  let scene,
    camera,
    renderer,
    rayCaster,
    control,
    flow,
    action = ACTION_NONE;

  let curves;

  /**
   * 初始化场景
   */
  const init = () => {
    scene = new THREE.Scene();

    // 创建一个三维坐标轴
    const axesHelper = new THREE.AxesHelper(150);
    scene.add(axesHelper);

    camera = new THREE.PerspectiveCamera(
      40,
      window.innerWidth / window.innerHeight,
      1,
      1000
    );
    camera.position.set(2, 2, 4);
    camera.lookAt(scene.position);

    const boxGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const boxMaterial = new THREE.MeshBasicMaterial();

    const r = 0.8;

    curves = [
      [
        // { x: 0.5, y: 0.5, z: 0 },
        { x: -r, y: 0.8, z: -r },
        { x: -r, y: 0.7, z: r },
        { x: r, y: 0.7, z: r },
        { x: r, y: 0.8, z: -r },
      ],
      [
        { x: r / 2, y: 0.5, z: 0 },
        { x: -r, y: 0.4, z: -r },
        { x: -r, y: 0.5, z: r },
        { x: r, y: 0.5, z: r },
        { x: r, y: 0.4, z: -r },
      ],
      [
        { x: r / 2, y: 0.1, z: 0 },
        { x: -r, y: 0.2, z: -r },
        { x: -r, y: 0.2, z: r },
        { x: r, y: 0.1, z: r },
        { x: r, y: 0.1, z: -r },
      ],
    ].map(function (curvePoints) {
      const curveVertices = curvePoints.map(function (handlePos) {
        // 添加控制器
        const handle = new THREE.Mesh(boxGeometry, boxMaterial);
        handle.position.copy(handlePos);
        // curveHandles.push(handle);
        // scene.add(handle);
        return handle.position;
      });

      const curve = new THREE.CatmullRomCurve3(curveVertices);
      curve.curveType = "centripetal";
      curve.closed = true;

      const points = curve.getPoints(50);

      // 线
      const line = new THREE.LineLoop(
        new THREE.BufferGeometry().setFromPoints(points),
        new THREE.LineBasicMaterial({ color: 0x00ff00 })
      );

      // scene.add(line);

      return {
        curve,
        line,
      };
    });

    //

    const light = new THREE.DirectionalLight(0xffaa33);
    light.position.set(-10, 10, 10);
    light.intensity = 1.0;
    scene.add(light);

    const light2 = new THREE.AmbientLight(0x003973);
    light2.intensity = 1.0;
    scene.add(light2);

    const loader = new FontLoader();
    loader.load("../lib/fonts/FZKai-Z03S_Regular.json", function (font) {
      const geometry = new TextGeometry("Hello three.js!", {
        font: font,
        size: 0.1,
        height: 0.001,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.02,
        bevelSize: 0.01,
        bevelOffset: 0,
        bevelSegments: 5,
      });

      geometry.rotateX(Math.PI);

      const material = new THREE.MeshStandardMaterial({
        color: 0x99ffff,
      });

      const numberOfInstances = 8;
      flow = new InstancedFlow(
        numberOfInstances,
        curves.length,
        geometry,
        material
      );

      curves.forEach(function ({ curve }, i) {
        flow.updateCurve(i, curve);
        scene.add(flow.object3D);
      });

      for (let i = 0; i < numberOfInstances; i++) {
        const curveIndex = i % curves.length;
        flow.setCurve(i, curveIndex);
        flow.moveIndividualAlongCurve(i, (i * 1) / numberOfInstances);
        flow.object3D.setColorAt(i, new THREE.Color(0xffffff));
      }
    });

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // rayCaster = new THREE.Raycaster();
    // control = new TransformControls(camera, renderer.domElement);
    // control.addEventListener("dragging-changed", function (event) {
    //   if (!event.value) {
    //     curves.forEach(function ({ curve, line }, i) {
    //       const points = curve.getPoints(50);
    //       line.geometry.setFromPoints(points);
    //       flow.updateCurve(i, curve);
    //     });
    //   }
    // });

    stats = new Stats();
    document.body.appendChild(stats.dom);

    window.addEventListener("resize", onWindowResize);
  };

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);

    if (flow) {
      curves.forEach(function ({ curve }, i) {
        const { points } = curve;

        for (let p of points) {
          // 添加震荡效果
          const time = Date.now() * 0.001;
          const amplitude = 0.05; // 震荡幅度
          const frequency = 0.1; // 震荡频率

          // p.x += Math.sin(time + i * 10) * amplitude * frequency;
          p.y += Math.sin(time) * frequency * amplitude;
        }

        flow.updateCurve(i, curve);
      });

      flow.moveAlongCurve(0.0009);
    }

    render();
  }

  function render() {
    renderer.render(scene, camera);

    stats.update();
  }

  init();
  animate();
</script>
